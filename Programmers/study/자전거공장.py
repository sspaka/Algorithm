# (1)지문 이해 및 풀이 계획
# 가장 효율적인 방법은 모든 생산을 달에 골고루 배치하는 것입니다. 하지만 주문이 앞쪽에 몰리면 골고루 할 수가 없습니다.
# 이때는 몰린 주문량을 우선 앞쪽에 골고루 배치하고, 나머지 수량을 뒤에 골고루 배치하면 됩니다.
#
# Part 1은 order의 month를 절대값에서 구간값으로 변경하는 과정입니다.
# 예를 들어 order = [[2, 300], [5, 10], [6, 100]] 일때
# 2개월(0~2)동안 300개를 만들고, 다음 3개월(2~5)동안 10개를 만들고 다음 1개월(5~6)동안 100개를 만들면 됩니다.
# 즉 다음과 같이 만들어야 합니다 => _order = [[2, 300], [3, 10], [1, 100]]
#
# Part2에서는 이제 이를 순차적으로 보면서 뒷쪽의 주문량이 더 많은 경우 앞쪽이랑 합쳐주는 과정입니다.
# 예를 들어 [2, 300] 요청이 있고 다음 [3, 10] 있는데, [2, 300] 은 월별 300 / 2 = 150개의 주문을 소화해야하고
# [3, 10] 은 월별 10 / 3 = 3.33개의 주문을 소화해야합니다.
# 주문이 앞쪽에 몰린 경우이므로 이는 합칠 수 없습니다. (300 / 2 > 10 / 3 : 풀이에서는 월에 0이 나올수 있으므로 역수로 비교함).
# 자 그다음 [3, 10] 이후 [1, 100] 를 마찬가지로 비교하면 10 / 3 < 100 / 1 이므로 뒷쪽에 주문이 몰린 경우므로 앞쪽으로 좀 주문량을 넘겨줄 수 있습니다.
# 즉 합칠 수 있습니다. [3, 10] + [1, 100] => [3+1, 10+110] => [3, 120], 새로 합쳐진 주문은 전과 비슷하게 다시 [2, 300] 비교하여 합쳐주거나 멈추면 됩니다.
# 최종적으로는 stack = [[2, 300], [4, 110]] 이 됩니다.
#
# Part3에서는 이제 구간별 가격을 구해주면 되는데, 문제에서 제공되는 갯수를 넘길때마다 그 넘긴 갯수만큼 차액을 계속 더해주면 되는 비교적 간단한 과정입니다.


def solution(cost, order):
    # part 1
    order.sort()
    _order = [order[0]]
    for i, (m, n) in enumerate(sorted(order)[1:]):
        _order.append([m - order[i][0], n])

    # part 2
    stack = []
    for m, n in _order:
        while stack:
            _m, _n = stack[-1]
            if _m / _n < m / n:
                break
            stack.pop()
            m, n = m + _m, n + _n
        stack.append([m, n])

    # part 3
    answer = 0
    for m, n in stack:
        p_prev = 0
        for t, p in cost:
            if m * t >= n:
                break
            answer += (n - m * t) * (p - p_prev)  # 넘긴 갯수 * 차액
            p_prev = p

    return answer