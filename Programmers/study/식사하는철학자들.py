# (1)지문 이해 및 풀이 계획
# 예시: satisfy: [6, 1, 9, 10, 8], k = 2
# 만족도가 가장 높은 사람이 식사를 하는 경우, 그렇지 않은 경우 두가지 경우로 나누어 생각해보자.
# 만족도가 가장 높은 사람이 식사를 하는 경우: 양 옆 사람이 못먹는다 정도만 반영하면 됨.
# 만족도가 가장 높은 사람이 식사를 하지 않는 경우, 이 경우 항상 양 옆사람이 식사를 해야만 한다. 그렇지 않으면 만족도가 가장 높은 사람이 식사를 최대값을 위해 포기할 이유가 없다. 예를 들어 위의 경우 만족도가 가장 높은 0번째 철학자는 만족도가 10으로 최대이다. 10 옆 8, 9 가 식사를 안하는 경우, 최대값을 위해서 10이 식사를 안할 이유가 없다. 8은 식사를 안하고 9만 식사를 하는 경우, 9대신 10이 먹는 경우가 +1 더 이득이다. 9는 식사를 안하고 8만 식사를 하는 경우도 마찬가지. 따라서 10이 식사를 안할만한 경우의 수는 9, 8 이 모두 식사를 하는 경우이다.
# [6, 1, 9, 10, 8], k = 2 의 문제를 => 10 + [6, 1, (9 + 8 - 10)], k = 1 의 문제로 바꿔 생각할 수 있다. 여기서 6, 1 을 선택하는 것은 그 전 문제에서의 6, 1 을 선택하는 것과 같고, (9 + 8 - 10) 을 선택하는 것은 10대신 그 양옆을 선택하는 것과 동치이다. 이런식으로 문제를 조금씩 줄여나가면서
# [6, 1, 9, 10, 8], k = 2
# 10 + [6, 1, (9 + 8 - 10) = 7], k = 1
# 10 + 7, k= 0
# 17을 정답으로 구할 수 있다.
# 테스트 케이스 [5, 4, 4, 6, 2, 1, 3], k = 3 의 경우 다음과 같다.
# [5, 4, 4, 6, 2, 1, 3], k = 3
# 6 + [5, 4, (4+2-6)=0, 1, 3], k = 2
# 6 + 5 + [(3+4-5)=2, 0, 1], k = 1
# 6 + 5 + 2, k = 0
# 정답은 13
#
# 테스트 케이스 [10, 1, 1, 10, 1, 1, 10, 1], k=4 의 경우 다음과 같다.
# [10, 1, 1, 10, 1, 1, 10, 1], k=4
# 10 + [(1+1-10)=-8, 1, 10, 1, 1, 10], k=3
# 10 + 10 + [-8, (1+1-10)=-8, 1, 10], k=2
# 10 + 10 + 10 + [-8, -8, ((1-8-10)=-17], k=1
# 음수만 남았으므로 더 이상 선택하지 않음: 정답 30

import heapq


def solution(satisfy, k):
    n = len(satisfy)
    l = list(range(-1, n - 1))  # 왼쪽 index
    r = list(range(1, n + 1))  # 오른쪽 index
    l[0] = n - 1
    r[n - 1] = 0
    visit = [0 for _ in range(n)]  # 식사를 할 수 있는지

    hq = [(-s, i) for i, s in enumerate(satisfy)]
    heapq.heapify(hq)

    ans = 0
    while hq and k:
        s, idx = heapq.heappop(hq)
        if visit[idx]:
            continue
        ans += -s
        satisfy[idx] = satisfy[l[idx]] + satisfy[r[idx]] - satisfy[idx]
        if satisfy[idx] > 0:
            heapq.heappush(hq, (-satisfy[idx], idx))
        visit[l[idx]] = visit[r[idx]] = True
        l[idx] = l[l[idx]]
        r[idx] = r[r[idx]]
        l[r[idx]] = idx
        r[l[idx]] = idx
        k -= 1

    return ans